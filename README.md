

# üìã Overview

The repository involves deploying two HTTP server pods behind a load balancer with ingress configuration, exposing the application to external traffic while implementing security and high availability best practices.

## üõ†Ô∏è Tech Stack

- **Runtime**: Node.js 22 with Express.js framework
- **Containerization**: Docker with multi-stage builds
- **Orchestration**: Kubernetes v1.33.1
- **Local Development**: Minikube with Docker driver
- **Package Management**: Helm v3
- **Ingress Controller**: NGINX Ingress Controller
- **Infrastructure as Code**: Helm Charts with templating
- **CLI Tools**: kubectl, docker, helm

## üìê Architecture

```
Internet ‚Üí Minikube Tunnel ‚Üí NGINX Ingress ‚Üí Service ‚Üí Pods (2 replicas)
```

- **High Availability**: 2 pod replicas with rolling updates
- **Load Balancing**: Kubernetes Service with round-robin distribution
- **Ingress**: NGINX controller for external traffic routing
- **Health Monitoring**: Readiness and liveness probes configured

## ‚ö° Quick Start

### Prerequisites

Ensure the following tools are installed and configured:

- **Minikube**: Running and configured
- **kubectl**: Configured to connect to your Minikube cluster
- **Helm**: v3.x installed
- **Docker**: For container operations
- **Git**: For repository cloning

Verify your setup:
```bash
minikube status
kubectl cluster-info
helm version
```

### üöÄ One-Command Deployment

1. **Clone the repository**:
```bash
git clone https://github.com/tohidsmart/tasker.git
cd tasker
```

2. **Run the deployment script**:
```bash
./infra/deployment.sh
```

The script automatically:
- Installs NGINX Ingress Controller
- Creates required namespaces
- Deploys the application with Helm
- Starts Minikube tunnel for external access

### üß™ Testing the Deployment

Once deployment completes, test both endpoints: ( The actual command will be generated by deployment script)

**Health Check Endpoint**:
```bash
curl http://airtasker.demo/healthcheck --resolve airtasker.demo:80:127.0.0.1
# Expected output: OK
```

**Main Application Endpoint**:
```bash
curl http://airtasker.demo/ --resolve airtasker.demo:80:127.0.0.1
# Expected output: airtasker
```


## üèóÔ∏è Application Structure

### HTTP Server Endpoints

The Express.js application exposes two endpoints as specified:

- **`GET /`**: Returns the value of `APP_NAME` environment variable (default: "airtasker")
  - Response: `Content-Type: text/plain`
  - Status: `200 OK`

- **`GET /healthcheck`**: Health monitoring endpoint
  - Response: `OK` with `Content-Type: text/plain`
  - Status: `200 OK`

### Environment Configuration

The `APP_NAME` environment variable can be configured through:

- Kubernetes ConfigMaps

## üõ°Ô∏è Production Readiness Considerations

### Container 
- **Multi-stage Docker build**
  - Separate user and group to run container
  - Small LTS base image 
  - Production-ready build
  - Image is built and tagged using semver and pushed to Docker hub

### Security

- **RBAC (Role-Based Access Control)**: 
  - Dedicated service accounts with minimal permissions
  - Role-based access to specific resources only
  - Principle of least privilege implemented

- **Pod Security Context**:
  - Non-root user execution (`runAsNonRoot: true`)
  - Read-only root filesystem
  - Dropped capabilities (`CAP_DROP: ALL`)
  - No privilege escalation allowed

- **Network Policies** (Optional):
  - Default deny-all traffic isolation
  - Selective ingress allowlisting for NGINX controller
  - Cross-namespace traffic restrictions
  - *Note: Requires CNI with NetworkPolicy support (Calico, Cilium)*


### High Availability

- **Multi-Replica Deployment**: 
  - 2 pod replicas for redundancy

- **Rolling Updates**:
  - Zero-downtime deployments
  - Configurable rollout strategy

- **Health Monitoring**:
  - **Readiness Probes**: Ensures pods are ready to receive traffic
  - **Liveness Probes**: Automatic restart of unhealthy pods

- **Resource Management**:
  - CPU and memory requests/limits defined
  - Horizontal Pod Autoscaler (HPA) ready


### Observability

- **Health Checks**: Built-in `/healthcheck` endpoint
- **Structured Logging**: Application logs with proper formatting ready for integration with external monitoring services.

### Scalability

- **Horizontal Pod Autoscaler (HPA)**:
  - CPU-based auto-scaling
  - Memory-based scaling support


## üìä Monitoring & Operations

### Checking Application Status

```bash
# View pod status and health
kubectl get pods -n airtasker

# Check service endpoints
kubectl get endpoints -n airtasker

# View ingress configuration
kubectl get ingress -n airtasker

# Monitor application logs
kubectl logs -f deployment/airtasker-app -n airtasker
```



## üéõÔ∏è Configuration

### Helm Values

Key configuration options in `values.yaml`:

```yaml
# Application configuration

configMap:
  enabled: true
  annotations: {}
  data:
    APP_NAME: "airtasker"
    NODE_ENV: "production"
    LOG_LEVEL: "info"
    LOG_FORMAT: "json"

# Scaling configuration
replicaCount: 2
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10

# Security configuration
rbac:
  enabled: true
networkPolicy:
  enabled: false  # Enable with supported CNI

# Resource management
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 256Mi
```


## üßπ Cleanup

To remove all deployed resources:

```bash

bash infra/undo-deployment.sh

# Stop tunnel
pkill -f "minikube tunnel"
```

## üö® Troubleshooting

### Common Issues

**1. 504 Gateway Timeout**
- Ensure Minikube tunnel is running: `minikube tunnel`
- Check pod readiness: `kubectl get pods -n airtasker`
- Verify service endpoints: `kubectl get endpoints -n airtasker`

**2. DNS Resolution Issues**
- Use IP-based resolution: `--resolve airtasker.demo:80:127.0.0.1`
- Check ingress status: `kubectl get ingress -n airtasker`

**3. Resource Issues**
- Increase Minikube resources: `minikube config set memory 4096`
- Check node resources: `kubectl describe nodes`

### Debug Commands

```bash
# Check deployment status
kubectl describe deployment airtasker-app -n airtasker

# View pod logs
kubectl logs -l app.kubernetes.io/name=airtasker-app -n airtasker

# Test internal connectivity
kubectl run debug --image=curlimages/curl --rm -it -- curl http://airtasker-app.airtasker.svc.cluster.local/

# Check ingress controller
kubectl logs -n ingress-nginx deployment/ingress-nginx-controller
```

## üèÜ Production Deployment Considerations

For production environments, I consider:

1. **Managed Kubernetes**: Use EKS, GKE, or AKS instead of Minikube
2. **Certificate Management**: Implement cert-manager with Let's Encrypt
3. **External DNS**: Automate DNS record management
4. **Monitoring Stack**: Deploy Prometheus, Grafana, and alerting
5. **GitOps**: Implement ArgoCD or Flux for automated deployments
6. **Security Scanning**: Container and vulnerability scanning pipelines
7. **Backup Strategy**: Persistent volume and configuration backup
8. **Disaster Recovery**: Multi-region deployment strategies
9. **Observability & Monitoring**: Log Aggregation Stack:
    - ELK/EFK: Elasticsearch + Fluentd/Fluent Bit + Kibana
    - Grafana Loki: Lightweight log aggregation with Grafana integration
   - Cloud Solutions: AWS CloudWatch, GCP Cloud Logging, Azure Monitor

## üìö Additional Resources

- [Kubernetes Documentation](https://kubernetes.io/docs/)
- [Helm Documentation](https://helm.sh/docs/)
- [NGINX Ingress Controller](https://kubernetes.github.io/ingress-nginx/)
- [Minikube Documentation](https://minikube.sigs.k8s.io/docs/)

---
